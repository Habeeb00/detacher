<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Detachr - Variable Manager</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        /* Updated Figma-inspired color palette */
        --figma-blue: #18a0fb;
        --figma-blue-hover: #1994e6;
        --figma-red: #f24822;
        --figma-red-hover: #d93915;
        --figma-success: #14ae5c;
        --figma-text: #ffffff;
        --figma-text-secondary: #b3b3b3;
        --figma-bg: #2c2c2c;
        --figma-bg-secondary: #383838;
        --figma-bg-tertiary: #444444;
        --figma-border: #444444;
        --figma-input-bg: #2c2c2c;

        /* Aliases for backward compatibility */
        --primary: var(--figma-blue);
        --primary-hover: var(--figma-blue-hover);
        --danger: var(--figma-red);
        --danger-hover: var(--figma-red-hover);
        --success: var(--figma-success);
        
        /* Scrollbar colors */
        --scrollbar-track: #2c2c2c;
        --scrollbar-thumb: #555555;
        --scrollbar-thumb-hover: #666666;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
      }
      
      /* Custom scrollbar for webkit browsers */
      ::-webkit-scrollbar {
        width: 5px;
        height: 5px;
      }
      
      ::-webkit-scrollbar-track {
        background: var(--scrollbar-track);
        border-radius: 3px;
      }
      
      ::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb);
        border-radius: 3px;
        transition: background 0.2s ease;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: var(--scrollbar-thumb-hover);
      }
      
      ::-webkit-scrollbar-corner {
        background: var(--scrollbar-track);
      }
      
      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        color: var(--figma-text);
        padding: 16px;
        max-width: 100%;
        overflow-x: hidden;
        background-color: var(--figma-bg);
      }
      .header {
        margin-bottom: 20px;
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 10px;
        color: var(--figma-text);
      }

      .summary {
        background: var(--figma-bg-secondary);
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 15px;
        border: 1px solid var(--figma-border);
      }
      .counts {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-top: 10px;
      }

      .count-item {
        text-align: center;
        padding: 6px 3px;
        background: var(--figma-bg-tertiary);
        border-radius: 3px;
        transition: all 0.2s ease;
      }

      .count-item:hover {
        background: #555555;
      }

      .count-number {
        font-size: 1rem;
        font-weight: 500;
        color: var(--figma-blue);
      }
      .count-label {
        font-size: 0.75rem;
        color: var(--figma-text-secondary);
      }
      .options {
        margin-bottom: 20px;
      }
      .checkbox-group {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 12px;
      }

      .checkbox-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        background: var(--figma-bg-tertiary);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s ease;
      }

      .checkbox-item:hover {
        background: #555555;
      }

      /* Figma-style checkbox */
      .checkbox-item input[type="checkbox"] {
        width: 14px;
        height: 14px;
        cursor: pointer;
        position: relative;
        appearance: none;
        border: 1px solid #777777;
        border-radius: 3px;
        outline: none;
        transition: all 0.2s ease;
        vertical-align: middle;
        background-color: var(--figma-input-bg);
      }

      .checkbox-item input[type="checkbox"]:checked {
        background-color: var(--figma-blue);
        border-color: var(--figma-blue);
      }

      .checkbox-item input[type="checkbox"]:checked::after {
        content: "";
        position: absolute;
        left: 3px;
        top: 1px;
        width: 5px;
        height: 7px;
        border: solid white;
        border-width: 0 1px 1px 0;
        transform: rotate(45deg);
      }
      .preview-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
        padding: 12px;
        background: rgba(24, 160, 251, 0.1);
        border-radius: 4px;
        font-size: 0.8rem;
      }

      .preview-toggle input[type="checkbox"] {
        width: 12px;
        height: 12px;
        cursor: pointer;
        position: relative;
        appearance: none;
        border: 1px solid #777777;
        border-radius: 2px;
        outline: none;
        transition: all 0.2s ease;
        vertical-align: middle;
        background-color: var(--figma-input-bg);
      }

      .preview-toggle input[type="checkbox"]:checked {
        background-color: var(--figma-blue);
        border-color: var(--figma-blue);
      }

      .preview-toggle input[type="checkbox"]:checked::after {
        content: "";
        position: absolute;
        left: 3px;
        top: 1px;
        width: 5px;
        height: 7px;
        border: solid white;
        border-width: 0 1px 1px 0;
        transform: rotate(45deg);
      }

      .preview-list {
        max-height: 200px;
        overflow-y: auto;
      }

      .preview-item {
        padding: 8px 10px;
        border-bottom: 1px solid var(--figma-border);
        font-size: 0.75rem;
      }
      
      .preview-item:last-child {
        border-bottom: none;
      }
      
      .preview-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
      }
      
      .preview-node-name {
        font-weight: 500;
        color: var(--figma-text);
      }
      
      .preview-property {
        color: var(--figma-text-secondary);
        font-size: 0.7rem;
      }
      
      .preview-content {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .before, .after {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .before {
        color: var(--figma-red);
        flex: 1;
      }

      .after {
        color: var(--figma-success);
        flex: 1;
      }
      
      .arrow {
        color: var(--figma-text-secondary);
        font-size: 0.9rem;
      }
      
      .color-swatch {
        display: inline-block;
        width: 14px;
        height: 14px;
        border-radius: 2px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 14px;
        height: 14px;
        border-radius: 2px;
        background: rgba(255, 255, 255, 0.1);
        font-size: 0.7rem;
        font-weight: 500;
      }
      
      .text-icon {
        background: rgba(24, 160, 251, 0.2);
        color: var(--figma-blue);
      }
      
      .number-icon {
        background: rgba(255, 149, 0, 0.2);
        color: #FF9500;
      }
      
      .boolean-icon {
        background: rgba(175, 82, 222, 0.2);
        color: #AF52DE;
      }
      
      .other-icon {
        background: rgba(255, 255, 255, 0.1);
        color: var(--figma-text-secondary);
      }
      
      .value {
        font-size: 0.7rem;
        word-break: break-word;
      }
      .button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        padding: 5px 12px;
        font-size: 0.7rem;
        font-weight: 500;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        transition: all 0.15s ease;
        margin-top: 4px;
      }

      .button-primary {
        background: var(--figma-blue);
        color: white;
      }

      .button-primary:hover {
        background: var(--figma-blue-hover);
      }
      .button-primary:active {
        opacity: 0.9;
      }

      .button-danger {
        background: var(--figma-red);
        color: white;
      }

      .button-danger:hover {
        background: var(--figma-red-hover);
      }

      .button-danger:active {
        opacity: 0.9;
      }

      .toast {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        padding: 8px 16px;
        background: #222222;
        color: white;
        border-radius: 2px;
        font-size: 0.7rem;
        opacity: 0;
        transition: all 0.2s ease;
        pointer-events: none;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
      }
      
      .toast.success {
        background-color: var(--figma-success);
        color: white;
        font-weight: 500;
      }
      
      .toast.error {
        background-color: var(--figma-red);
        color: white;
        font-weight: 500;
      }
      
      .toast.info {
        background-color: var(--figma-blue);
        color: white;
        font-weight: 500;
      }

      .preview-section {
        margin-top: 16px;
        border: 1px solid var(--figma-border);
        border-radius: 4px;
        background: var(--figma-bg-tertiary);
        overflow: hidden;
      }
      
      .preview-header-toggle {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        background: var(--figma-bg-secondary);
        border-bottom: 1px solid var(--figma-border);
        user-select: none;
      }
      
      .preview-header-toggle:hover {
        background: var(--figma-bg-tertiary);
      }
      
      .preview-title {
        font-weight: 500;
        font-size: 0.8rem;
      }
      
      .preview-count {
        color: var(--figma-text-secondary);
        font-size: 0.7rem;
      }
      
      .toggle-icon {
        font-size: 0.7rem;
        color: var(--figma-text-secondary);
        transition: transform 0.2s ease;
      }
      
      .toggle-icon.open {
        transform: rotate(180deg);
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Detacher</h1>
      <p
        style="
          font-size: 0.7rem;
          color: var(--figma-text-secondary);
          margin-top: 2px;
        "
      >
        Scan and detach variables from your selection
      </p>
    </div>

    <div class="summary">
      <h2
        style="
          font-size: 0.8rem;
          font-weight: 500;
          margin-bottom: 4px;
          color: var(--figma-text-secondary);
        "
      >
        Variable Summary
      </h2>
      <div class="counts">
        <div class="count-item">
          <div class="count-number" id="colorCount">0</div>
          <div class="count-label">Colors</div>
        </div>
        <div class="count-item">
          <div class="count-number" id="textCount">0</div>
          <div class="count-label">Text</div>
        </div>
        <div class="count-item">
          <div class="count-number" id="numberCount">0</div>
          <div class="count-label">Numbers</div>
        </div>
        <div class="count-item">
          <div class="count-number" id="otherCount">0</div>
          <div class="count-label">Other</div>
        </div>
        <div class="count-item">
          <div class="count-number" id="totalCount">0</div>
          <div class="count-label">Total</div>
        </div>
      </div>
    </div>

    <div class="options">
      <div class="checkbox-group">
        <label class="checkbox-item">
          <input type="checkbox" id="colorToggle" checked />
          Colors
        </label>
        <label class="checkbox-item">
          <input type="checkbox" id="textToggle" checked />
          Text
        </label>
        <label class="checkbox-item">
          <input type="checkbox" id="numberToggle" checked />
          Numbers
        </label>
        <label class="checkbox-item">
          <input type="checkbox" id="otherToggle" checked />
          Other
        </label>
      </div>

      <div class="preview-toggle">
        <input type="checkbox" id="dryRunToggle" checked />
        <label for="dryRunToggle">
          Require Preview Before Detach
        </label>
      </div>
    </div>

    <div class="preview-section" style="display: none;" id="previewSection">
      <div class="preview-header-toggle" id="previewHeaderToggle">
        <span class="preview-title">Preview Changes</span>
        <span class="preview-count" id="previewCount">(0)</span>
        <span class="toggle-icon">▼</span>
      </div>
      <div id="previewList" class="preview-list"></div>
    </div>

    <button id="detachButton" class="button button-primary">
      Preview Changes
    </button>

    <div id="toast" class="toast"></div>

    <script>
      // UI Event Handlers and State Management
      let currentBindings = [];
      let isDryRun = true;
      let hasPreviewedChanges = false;

      // Store the full counts from the scan
      let fullCounts = {
        color: 0,
        text: 0,
        number: 0,
        other: 0,
        total: 0
      };

      // Initialize UI
      document.addEventListener("DOMContentLoaded", () => {
        console.log("UI initialized, sending scan request");
        
        // Initial scan
        parent.postMessage({ pluginMessage: { type: "scan" } }, "*");
        showToast("Scanning for variables...");

        // Setup event listeners
        setupEventListeners();
        
        // Ensure all checkboxes are checked initially
        document.getElementById("colorToggle").checked = true;
        document.getElementById("textToggle").checked = true;
        document.getElementById("numberToggle").checked = true;
        document.getElementById("otherToggle").checked = true;
        
        // Update filtered counts based on initial checkbox state
        updateFilteredCounts();
      });

      function setupEventListeners() {
        // Detach button
        const detachButton = document.getElementById("detachButton");
        detachButton.addEventListener("click", handleDetachClick);

        // Dry run toggle
        const dryRunToggle = document.getElementById("dryRunToggle");
        dryRunToggle.addEventListener("change", (e) => {
          isDryRun = e.target.checked;
          updateDetachButtonText();
        });
        
        // Preview header toggle
        const previewHeaderToggle = document.getElementById("previewHeaderToggle");
        previewHeaderToggle.addEventListener("click", togglePreviewList);
        
        // Set up listeners for all checkbox toggles
        const checkboxToggles = [
          "colorToggle", 
          "textToggle", 
          "numberToggle", 
          "otherToggle"
        ];
        
        checkboxToggles.forEach(toggleId => {
          const toggle = document.getElementById(toggleId);
          if (toggle) {
            toggle.addEventListener("change", () => {
              console.log(`${toggleId} changed to ${toggle.checked}`);
              // Update the counts display when checkboxes change
              updateFilteredCounts();
              // If we have previewed changes, refresh the preview
              if (hasPreviewedChanges) {
                handleDetachClick();
              }
            });
          }
        });
      }

      function togglePreviewList() {
        const previewList = document.getElementById("previewList");
        const toggleIcon = document.querySelector(".toggle-icon");
        
        if (previewList.style.display === "none") {
          previewList.style.display = "block";
          toggleIcon.classList.add("open");
        } else {
          previewList.style.display = "none";
          toggleIcon.classList.remove("open");
        }
      }

      function updateDetachButtonText() {
        const detachButton = document.getElementById("detachButton");
        
        if (isDryRun) {
          detachButton.textContent = "Preview Changes";
          detachButton.className = "button button-primary";
          hasPreviewedChanges = false;
          console.log("Button updated: Preview Changes mode");
        } else {
          // When dry run is off, always show "Detach Variables" button
          detachButton.textContent = "Detach Variables";
          detachButton.className = "button button-danger";
          console.log("Button updated: Detach Variables mode");
        }
      }

      function getSelectedOptions() {
        const options = {
          color: document.getElementById("colorToggle").checked,
          text: document.getElementById("textToggle").checked,
          number: document.getElementById("numberToggle").checked,
          other: document.getElementById("otherToggle").checked,
          dryRun: isDryRun,
        };
        console.log("Current options:", options);
        return options;
      }

      function updateFilteredCounts() {
        // Get current checkbox states
        const options = getSelectedOptions();
        
        // Calculate filtered counts based on checkbox selection
        const filteredCounts = {
          color: options.color ? fullCounts.color : 0,
          text: options.text ? fullCounts.text : 0,
          number: options.number ? fullCounts.number : 0,
          other: options.other ? fullCounts.other : 0,
          total: 0
        };
        
        // Calculate total from selected types
        filteredCounts.total = Object.keys(filteredCounts)
          .filter(key => key !== 'total')
          .reduce((sum, key) => sum + filteredCounts[key], 0);
        
        // Update the UI with filtered counts
        updateCountsDisplay(filteredCounts);
      }

      function updateCounts(counts) {
        console.log("Updating counts:", counts);
        // Store the full counts
        fullCounts = { ...counts };
        
        // Update the display with filtered counts based on current selection
        updateFilteredCounts();
      }
      
      function updateCountsDisplay(counts) {
        Object.entries(counts).forEach(([key, value]) => {
          const element = document.getElementById(`${key}Count`);
          if (element) {
            element.textContent = String(value);
          }
        });
      }

      function showToast(message, type = 'default') {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        
        // Remove any existing classes
        toast.classList.remove("show", "success", "error", "info");
        
        // Add the appropriate class based on type
        toast.classList.add("show");
        if (type === 'success') {
          toast.classList.add("success");
        } else if (type === 'error') {
          toast.classList.add("error");
        } else if (type === 'info') {
          toast.classList.add("info");
        }
        
        // Clear any existing timeout
        if (window.toastTimeout) {
          clearTimeout(window.toastTimeout);
        }
        
        // Set timeout based on type
        const duration = type === 'success' ? 2000 : 3000;
        window.toastTimeout = setTimeout(() => {
          toast.classList.remove("show", "success", "error", "info");
          
          // If this was a success message from detachment, check for variables after toast disappears
          if (type === 'success' && message.includes('Successfully detached')) {
            checkForVariablesAfterDelay(500);
          }
        }, duration);
      }
      
      function checkForVariablesAfterDelay(delay) {
        setTimeout(() => {
          if (fullCounts.total === 0) {
            showToast("No variables found. Try selecting different elements.");
          }
        }, delay);
      }

      function updatePreviewList(detached) {
        const previewSection = document.getElementById("previewSection");
        const previewList = document.getElementById("previewList");
        const previewCount = document.getElementById("previewCount");
        
        // Update preview count
        previewCount.textContent = `(${detached.length})`;
        
        // Show preview section if there are items to display
        previewSection.style.display = detached.length > 0 ? "block" : "none";
        
        // Initially hide the preview list (will be shown when dropdown is clicked)
        previewList.style.display = "none";
        
        // Remove the open class from toggle icon
        const toggleIcon = document.querySelector(".toggle-icon");
        if (toggleIcon) toggleIcon.classList.remove("open");

        if (detached.length > 0) {
          previewList.innerHTML = detached
            .map(
              (item) => {
                // Create a visual representation based on the variable type
                let visualBefore = '';
                let visualAfter = '';
                
                // Handle different variable types
                if (item.variableType === 'color') {
                  // For colors, show color swatches
                  const beforeColor = item.currentVariable.startsWith('#') ? 
                    item.currentVariable : 
                    (typeof item.resolvedValue === 'string' && item.resolvedValue.startsWith('#') ? 
                      item.resolvedValue : '#CCCCCC');
                  
                  const afterColor = typeof item.resolvedValue === 'string' && item.resolvedValue.startsWith('#') ? 
                    item.resolvedValue : '#CCCCCC';
                  
                  visualBefore = `<span class="color-swatch" style="background-color: ${beforeColor}"></span>`;
                  visualAfter = `<span class="color-swatch" style="background-color: ${afterColor}"></span>`;
                } else if (item.variableType === 'text') {
                  // For text, show a text icon
                  visualBefore = `<span class="icon text-icon">T</span>`;
                  visualAfter = `<span class="icon text-icon">T</span>`;
                } else if (item.variableType === 'number') {
                  // For numbers, show a ruler icon
                  visualBefore = `<span class="icon number-icon">#</span>`;
                  visualAfter = `<span class="icon number-icon">#</span>`;
                } else {
                  // For other types, show a generic icon
                  visualBefore = `<span class="icon other-icon">•</span>`;
                  visualAfter = `<span class="icon other-icon">•</span>`;
                }
                
                // Format the property name to be more readable
                const propertyName = item.property
                  .replace(/([A-Z])/g, ' $1') // Add space before capital letters
                  .replace(/^./, str => str.toUpperCase()); // Capitalize first letter
                
                return `
                  <div class="preview-item">
                    <div class="preview-header">
                      <span class="preview-node-name">${item.nodeName}</span>
                      <span class="preview-property">${propertyName}</span>
                    </div>
                    <div class="preview-content">
                      <div class="before">
                        ${visualBefore}
                        <span class="value">${item.currentVariable}</span>
                      </div>
                      <div class="arrow">→</div>
                      <div class="after">
                        ${visualAfter}
                        <span class="value">${String(item.resolvedValue).substring(0, 30)}${String(item.resolvedValue).length > 30 ? '...' : ''}</span>
                      </div>
                    </div>
                  </div>
                `;
              }
            )
            .join("");
        }
      }

      function handleDetachClick() {
        const options = getSelectedOptions();
        console.log("Detach button clicked. Current button text:", document.getElementById("detachButton").textContent);
        console.log("isDryRun:", isDryRun, "hasPreviewedChanges:", hasPreviewedChanges);
        
        // If preview mode is on, generate preview
        if (isDryRun) {
          console.log("Preview mode active. Generating preview...");
          parent.postMessage(
            {
              pluginMessage: {
                type: "detach",
                payload: {
                  bindings: currentBindings,
                  options,
                },
              },
            },
            "*"
          );
          showToast("Generating preview...");
        } 
        // If preview mode is off, perform detachment
        else {
          // Proceed with actual detachment
          console.log("Detachment mode active. Detaching variables...");
          parent.postMessage(
            {
              pluginMessage: {
                type: "detach",
                payload: {
                  bindings: currentBindings,
                  options,
                },
              },
            },
            "*"
          );
          showToast("Detaching variables...");
        }
      }

      // Listen for messages from the plugin code
      window.onmessage = (event) => {
        const message = event.data.pluginMessage;
        console.log("Received message:", message);

        if (!message) {
          console.warn("Received empty message");
          return;
        }

        switch (message.type) {
          case "scan-results":
            console.log("Received scan results:", message.payload);
            currentBindings = message.payload.bindings;
            updateCounts(message.payload.counts);
            
            // Show selection notification if needed
            if (message.payload.noSelection) {
              showToast("Please select frames, layers, or components to scan for variables.", 'info');
              return;
            }
            
            // Only show "No variables found" if not immediately after a detachment
            if (message.payload.counts.total === 0 && !message.payload.afterDetach) {
              showToast("No variables found. Try selecting different elements.");
            } else if (!message.payload.afterDetach) {
              showToast(`Found ${message.payload.counts.total} variables.`);
            }
            break;

          case "detach-results":
            console.log("Received detach results:", message.payload);
            console.log("Current state - isDryRun:", isDryRun, "hasPreviewedChanges:", hasPreviewedChanges);
            updatePreviewList(message.payload.detached);
            
            if (message.payload.dryRun) {
              showToast(`Preview generated for ${message.payload.detached.length} variables.`);
              hasPreviewedChanges = true;
              // After preview, toggle to detach mode
              isDryRun = false;
              console.log("Preview completed. Updated state - isDryRun:", isDryRun, "hasPreviewedChanges:", hasPreviewedChanges);
              updateDetachButtonText();
            } else {
              showToast(
                `✓ Successfully detached ${message.payload.counts.total} variables!`,
                'success'
              );
              console.log("Detachment successful. Refreshing scan...");
              // Reset preview state after successful detach
              hasPreviewedChanges = false;
              // Reset to preview mode after detaching
              isDryRun = true;
              console.log("Detachment completed. Updated state - isDryRun:", isDryRun, "hasPreviewedChanges:", hasPreviewedChanges);
              updateDetachButtonText();
              
              // Refresh scan after detaching
              parent.postMessage({ pluginMessage: { type: "scan", afterDetach: true } }, "*");
            }
            break;

          case "error":
            console.error("Error from plugin:", message.payload);
            showToast(`Error: ${message.payload.message}`, 'error');
            break;

          case "no-selection":
            console.log("No selection:", message.payload);
            showToast(message.payload.message, 'error');
            break;

          case "show-about":
            // Handle about dialog
            break;
            
          default:
            console.warn("Unknown message type:", message.type);
        }
      };
    </script>
  </body>
</html>
